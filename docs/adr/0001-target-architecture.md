# ADR 0001: Целевая архитектура продукта

- **Статус:** Принято
- **Дата:** 2024-05-15
- **Ответственные:** Архитектор продукта, тимлид фронтенда, тимлид бэкенда
- **Согласование:** Утверждено архитектурным комитетом

## Контекст
Продукту требуется целевое архитектурное описание, позволяющее согласованно развивать фронтенд и бэкенд, планировать интеграции и управлять техническими ограничениями. Документ фиксирует договоренности, которые обеспечивают масштабируемость, наблюдаемость и предсказуемость доставки новых возможностей.

## Решение
Вводится многослойная архитектура с чёткими границами ответственности, стандартизированными интеграциями и набором базовых паттернов. Все изменения архитектуры проходят через архитектурный комитет, который обеспечивает непротиворечивость решений и соответствие нефункциональным требованиям.

## Слои системы
1. **Клиентский слой (Frontend Web, Mobile Web).**
   - Стек: Vite + TypeScript + React, UI-библиотека проекта.
   - Ответственность: отображение интерфейсов, клиентская маршрутизация, работа с API и трекингом событий.
   - Контракты: HTTP/JSON API, Feature Toggles, Web Analytics SDK.
2. **API Gateway / BFF.**
   - Стек: Node.js + NestJS/Express (для BFF), инфраструктурные плагины для авторизации и трейсинга.
   - Ответственность: агрегация данных для конкретных сценариев, нормализация ответов, кеширование, периметр безопасности.
   - Контракты: REST/GraphQL наружу; gRPC/HTTP внутрь.
3. **Сервисный слой.**
   - Стек: микросервисы на Go/Java/Node.js в зависимости от домена.
   - Ответственность: бизнес-логика доменов, правила валидации, авторизация доменных операций.
   - Контракты: gRPC между сервисами, REST для публичных/партнёрских API.
4. **Данные и интеграции.**
   - Стек: PostgreSQL для транзакционных данных, Redis/Memcached для кешей, S3-совместимое хранилище для файлов, Kafka для событий.
   - Ответственность: долговременное хранение, очереди событий, контрактные интеграции с внешними системами.

## Интеграции
- **Внутренние сервисы:** gRPC с версионированными proto, строгая совместимость назад; сервисная авторизация через mTLS или JWT от сервис-аккаунтов.
- **Внешние партнёры:** REST/JSON с OAuth2 или подписанными ключами; выделенные адаптеры в интеграционном слое, чтобы изолировать внешний трафик от доменного кода.
- **Наблюдаемость:** обязательный трейсинг (OpenTelemetry), структурированные логи, метрики Prometheus; единые корелляционные идентификаторы на весь запрос.
- **Фича-флаги и конфиг:** централизованный сервис конфигураций (например, ConfigCat/Unleash), bootstrap при старте и обновление по push/poll.

## Ключевые паттерны
- **Hexagonal/Ports & Adapters** для сервисов: доменная логика изолирована от транспорта и инфраструктуры.
- **BFF-per-experience**: отдельные фасады для веба/мобайла сокращают связность между клиентом и сервисами.
- **CQRS с тонкой гранулярностью** для сложных доменов: чтение оптимизировано под сценарии, запись — под инварианты.
- **Event-driven** взаимодействие между доменами через Kafka; критичные цепочки подтверждаются outbox-паттерном.
- **API-first**: контракты описываются OpenAPI/Proto, автогенерация клиентских SDK и контрактное тестирование.

## Ограничения и принципы
- **Безопасность:** обязательный TLS, секреты только из секрет-менеджера; минимальные привилегии для сервисных аккаунтов.
- **Производительность:** P99 для пользовательских запросов ≤ 400 мс на BFF; асинхронные операции выносятся в очереди.
- **Надёжность:** целевые SLO — доступность 99.9% для клиентских API; кросс-зонное развертывание обязательное.
- **Схемы данных:** миграции только через миграционные тулзы с ревью; несовместимые изменения проходят двойное развертывание.
- **Совместимость:** версии API поддерживаются минимум 2 релизных цикла; депрекейты фиксируются в changelog и аналитике использования.

## Последствия
- Повышается прозрачность ответственности между слоями, упрощается планирование backlog для каждой команды.
- Уменьшается риск неконтролируемых интеграций благодаря централизованным адаптерам и единым контрактам.
- Требуется дисциплина в поддержке схем, версий и трейсинга; без них деградирует наблюдаемость и обратная совместимость.

## План внедрения
1. Утвердить целевую архитектуру на ближайшем заседании архитектурного комитета и зафиксировать решение в протоколе.
2. Создать дорожную карту миграции по слоям: BFF, сервисы, интеграции.
3. Настроить шаблоны контрактных тестов и outbox для существующих сервисов.
4. Включить проверку архитектурных ограничений в Definition of Done.

## Статус согласования
- **Архитектурный комитет:** решение о принятии зафиксировано в протоколе заседания от 2024-05-15.
- **Следующий пересмотр:** не позднее чем через два релизных цикла или при появлении критичных изменений в интеграциях.
